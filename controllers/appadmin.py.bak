# File: controllers/appadmin.py
# -*- coding: utf-8 -*-
"""
AppAdmin Controller

This module provides a complete administration interface for your application's
database. It includes functionality for listing databases/tables, inserting and
updating records, managing file uploads/downloads, cache control, and visualizing
the database model via D3.js.
"""

import os
import socket
import datetime
import copy
import logging
import re
import math
import time

# Import globals from gluon.globals and necessary tools from gluon.tools.
from gluon.globals import response, request, session
from gluon.tools import redirect, URL, SQLFORM
from gluon.html import FORM, TABLE, TR, TD, DIV, PRE, TAG, UL, LI, B
from gluon import current

# Retrieve the translation function from the current environment.
T = current.T

logging.basicConfig(level=logging.DEBUG)

# Determine if running on Google App Engine (GAE)
is_gae = request.env.web2py_runtime_gae or False

# Make a copy of the current global environment to allow dynamic evaluation later.
global_env = copy.copy(globals())
global_env['datetime'] = datetime

http_host = request.env.http_host.split(':')[0]
remote_addr = request.env.remote_addr
try:
    hosts = (
        http_host,
        socket.gethostname(),
        socket.gethostbyname(http_host),
        '::1',
        '127.0.0.1',
        '::ffff:127.0.0.1'
    )
except Exception:
    hosts = (http_host,)

# Enforce secure channels and local access.
if request.is_https:
    session.secure()
elif request.env.trusted_lan_prefix and remote_addr.startswith(request.env.trusted_lan_prefix):
    request.is_local = True
elif (remote_addr not in hosts) and (remote_addr != '127.0.0.1') and (request.function != 'manage'):
    raise HTTP(200, T('appadmin is disabled because insecure channel'))

# Only allow manager actions if proper credentials are provided.
if request.function == 'manage':
    if 'auth' not in globals() or not request.args:
        redirect(URL(request.controller, 'index'))
    manager_action = auth.settings.manager_actions.get(request.args(0), None)
    if manager_action is None and request.args(0) == 'auth':
        manager_action = {
            'role': auth.settings.auth_manager_role,
            'heading': T('Manage Access Control'),
            'tables': [auth.table_user(), auth.table_group(), auth.table_permission()]
        }
    manager_role = manager_action.get('role', None) if manager_action else None
    if not (gluon.fileutils.check_credentials(request) or auth.has_membership(manager_role)):
        raise HTTP(403, 'Not authorized')
    menu = False
elif (request.application == 'admin' and not session.authorized) or \
     (request.application != 'admin' and not gluon.fileutils.check_credentials(request)):
    redirect(URL('admin', 'default', 'index', vars=dict(send=URL(args=request.args, vars=request.vars))))
else:
    response.subtitle = T('Database Administration (appadmin)')
    menu = True

ignore_rw = True
response.view = 'appadmin.html'
if menu:
    response.menu = [
        [T('design'), False, URL('admin', 'default', 'design', args=[request.application])],
        [T('db'), False, URL('index')],
        [T('state'), False, URL('state')],
        [T('cache'), False, URL('ccache')]
    ]

# ------------------------------ Auxiliary Functions ------------------------------

def get_databases(request):
    """
    Returns a dictionary of available database objects from the global environment.
    """
    dbs = {}
    for key, value in global_env.items():
        try:
            cond = isinstance(value, GQLDB)
        except Exception:
            cond = isinstance(value, SQLDB)
        if cond:
            dbs[key] = value
    return dbs

databases = get_databases(None)

def eval_in_global_env(text):
    """
    Safely execute the provided text in the global environment and return the result.
    """
    exec(f'_ret={text}', {}, global_env)
    return global_env['_ret']

def get_database(request):
    """
    Retrieve the database object based on request arguments.
    """
    if request.args and request.args[0] in databases:
        return eval_in_global_env(request.args[0])
    else:
        session.flash = T('invalid request')
        redirect(URL('index'))

def get_table(request):
    """
    Retrieve both the database and specific table object using the request arguments.
    """
    dbobj = get_database(request)
    if len(request.args) > 1 and request.args[1] in dbobj.tables:
        return (dbobj, request.args[1])
    else:
        session.flash = T('invalid request')
        redirect(URL('index'))

def get_query(request):
    """
    Evaluate and return the query parameter from the request.
    """
    try:
        return eval_in_global_env(request.vars.query)
    except Exception:
        return None

def query_by_table_type(tablename, dbobj, request=request):
    """
    Construct a default query for the table based on its primary key if no query is provided.
    """
    keyed = hasattr(dbobj[tablename], '_primarykey')
    if keyed:
        firstkey = dbobj[tablename][dbobj[tablename]._primarykey[0]]
        cond = '>0'
        if firstkey.type in ['string', 'text']:
            cond = '!=""'
        qry = f'{request.args[0]}.{request.args[1]}.{firstkey.name}{cond}'
    else:
        qry = f'{request.args[0]}.{request.args[1]}.id>0'
    return qry

# ------------------ List All Databases and Tables ------------------

def index():
    """
    Display a list of available databases.
    """
    return dict(databases=databases)

# ------------------ Insert a New Record ------------------

def insert():
    """
    Render a form for inserting a new record into a table.
    """
    (dbobj, table) = get_table(request)
    form = SQLFORM(dbobj[table], ignore_rw=ignore_rw)
    if form.accepts(request.vars, session):
        response.flash = T('new record inserted')
    return dict(form=form, table=dbobj[table])

# ------------------ Download and CSV Functions ------------------

def download():
    """
    Helper to enable file download of records.
    """
    import os
    dbobj = get_database(request)
    return response.download(request, dbobj)

def csv():
    """
    Export records as CSV.
    """
    import gluon.contenttype
    response.headers['Content-Type'] = gluon.contenttype.contenttype('.csv')
    dbobj = get_database(request)
    query = get_query(request)
    if not query:
        return None
    parts = request.vars.query.split('.')
    filename = f'{parts[0]}_{parts[1]}.csv' if len(parts) >= 2 else 'data.csv'
    response.headers['Content-disposition'] = f'attachment; filename={filename}'
    return str(dbobj(query, ignore_common_filters=True).select())

def import_csv(table, file):
    """
    Import CSV data into the specified table.
    """
    table.import_from_csv_file(file)

# ------------------ Select, Update, and Delete Records ------------------

def select():
    """
    Provides a unified interface to view, update, or delete records.
    Supports query, bulk update or deletion, as well as CSV upload.
    """
    dbobj = get_database(request)
    dbname = request.args[0]
    try:
        is_imap = dbobj._uri.startswith('imap://')
    except (KeyError, AttributeError, TypeError):
        is_imap = False
    regex = re.compile(r'(?P<table>\w+)\.(?P<field>\w+)=(?P<value>\d+)')
    if len(request.args) > 1 and hasattr(dbobj[request.args[1]], '_primarykey'):
        regex = re.compile(r'(?P<table>\w+)\.(?P<field>\w+)=(?P<value>.+)')
    if request.vars.query:
        match = regex.match(request.vars.query)
        if match:
            request.vars.query = f'{request.args[0]}.{match.group("table")}.{match.group("field")}=={match.group("value")}'
    query = get_query(request)
    start = int(request.vars.start) if request.vars.start else 0
    step = 100 if not is_imap else 3
    stop = start + step
    orderby = request.vars.orderby
    if orderby:
        orderby = dbname + '.' + orderby
        if orderby == session.get('last_orderby', ''):
            orderby = orderby[1:] if orderby[0] == '~' else '~' + orderby
    session.last_orderby = orderby
    form = FORM(
        TABLE(
            TR(
                TD(T('Query:')),
                TD(INPUT(_style='width:400px', _name='query',
                         _value=request.vars.query or '',
                         _class='form-control',
                         requires=IS_NOT_EMPTY(error_message=T('Cannot be empty'))))
            ),
            TR(
                TD(T('Update:')),
                TD(
                    INPUT(_name='update_check', _type='checkbox', value=False),
                    INPUT(_style='width:400px', _name='update_fields',
                          _value=request.vars.update_fields or '', _class='form-control')
                )
            ),
            TR(
                TD(T('Delete:')),
                TD(INPUT(_name='delete_check', _class='delete',
                         _type='checkbox', value=False))
            ),
            TR(
                TD(INPUT(_type='submit', _value=T('Submit'), _class='btn btn-primary'))
            )
        ),
        _action=URL(r=request, args=request.args)
    )
    tb = None
    try:
        if form.accepts(request.vars, formname=None):
            regex = re.compile(request.args[0] + r'\.(?P<table>\w+)\..+')
            match = regex.match(form.vars.query.strip())
            table = match.group('table') if match else None
            nrows = dbobj(query, ignore_common_filters=True).count()
            if form.vars.update_check and form.vars.update_fields:
                dbobj(query, ignore_common_filters=True).update(
                    **eval_in_global_env(f'dict({form.vars.update_fields})')
                )
                response.flash = T(f'{nrows} row(s) updated')
            elif form.vars.delete_check:
                dbobj(query, ignore_common_filters=True).delete()
                response.flash = T(f'{nrows} row(s) deleted')
            nrows = dbobj(query, ignore_common_filters=True).count()
            fields = []
            if is_imap and table:
                fields = [dbobj[table][name] for name in ('id', 'uid', 'created', 'to', 'sender', 'subject')]
            rows = dbobj(query, ignore_common_filters=True).select(
                *fields, limitby=(start, stop),
                orderby=eval_in_global_env(orderby) if orderby else None
            )
        else:
            nrows = 0
            rows = []
    except Exception as e:
        import traceback
        tb = traceback.format_exc()
        rows, nrows = [], 0
        response.flash = DIV(T('Invalid Query'), PRE(str(e)))
    # Handle CSV upload form
    csv_table = table or request.vars.table
    formcsv = None
    if csv_table:
        formcsv = FORM(
            f"{T('or import from csv file')} ",
            INPUT(_type='file', _name='csvfile'),
            INPUT(_type='hidden', _value=csv_table, _name='table'),
            INPUT(_type='submit', _value=T('import'), _class='btn btn-primary')
        )
    if formcsv and formcsv.process().accepted:
        try:
            import_csv(dbobj[request.vars.table], request.vars.csvfile.file)
            response.flash = T('data uploaded')
        except Exception as e:
            response.flash = DIV(T('unable to parse csv file'), PRE(str(e)))
    return dict(
        form=form,
        table=table,
        start=start,
        stop=stop,
        step=step,
        nrows=nrows,
        rows=rows,
        query=request.vars.query,
        formcsv=formcsv,
        tb=tb if 'tb' in locals() else None
    )

def update():
    """
    Edit or delete a single record.
    """
    (dbobj, table) = get_table(request)
    keyed = hasattr(dbobj[table], '_primarykey')
    record = None
    dbobj[table]._common_filter = None
    if keyed:
        key = [f for f in request.vars if f in dbobj[table]._primarykey]
        if key:
            record = dbobj(dbobj[table][key[0]] == request.vars[key[0]]).select().first()
    else:
        record = dbobj(dbobj[table].id == request.args(2)).select().first()
    if not record:
        qry = query_by_table_type(table, dbobj)
        session.flash = T('record does not exist')
        redirect(URL('select', args=request.args[:1], vars=dict(query=qry)))
    if keyed:
        for k in dbobj[table]._primarykey:
            dbobj[table][k].writable = False
    form = SQLFORM(
        dbobj[table], record, deletable=True, delete_label=T('Check to delete'),
        ignore_rw=ignore_rw and not keyed,
        linkto=URL('select', args=request.args[:1]),
        upload=URL(r=request, f='download', args=request.args[:1])
    )
    if form.accepts(request.vars, session):
        session.flash = T('done!')
        qry = query_by_table_type(table, dbobj)
        redirect(URL('select', args=request.args[:1], vars=dict(query=qry)))
    return dict(form=form, table=dbobj[table])

def state():
    """
    Display system state information.
    """
    return dict()

def ccache():
    """
    Provide an interface to clear cache and display cache statistics.
    """
    if is_gae:
        form = FORM(P(TAG.BUTTON(T('Clear CACHE?'), _type='submit', _name='yes', _value='yes')))
    else:
        cache.ram.initialize()
        cache.disk.initialize()
        form = FORM(
            P(TAG.BUTTON(T('Clear CACHE?'), _type='submit', _name='yes', _value='yes')),
            P(TAG.BUTTON(T('Clear RAM'), _type='submit', _name='ram', _value='ram')),
            P(TAG.BUTTON(T('Clear DISK'), _type='submit', _name='disk', _value='disk'))
        )
    if form.accepts(request.vars, session):
        session.flash = ''
        if is_gae:
            if request.vars.yes:
                cache.ram.clear()
                session.flash += T('Cache Cleared')
        else:
            clear_ram = request.vars.get('yes') or request.vars.get('ram')
            clear_disk = request.vars.get('yes') or request.vars.get('disk')
            if clear_ram:
                cache.ram.clear()
                session.flash += T('Ram Cleared')
            if clear_disk:
                cache.disk.clear()
                session.flash += T('Disk Cleared')
        redirect(URL(r=request))
    try:
        from pympler.asizeof import asizeof
    except ImportError:
        asizeof = False
    ram = {'entries': 0, 'bytes': 0, 'objects': 0, 'hits': 0, 'misses': 0, 'ratio': 0,
           'oldest': time.time(), 'keys': []}
    disk = copy.copy(ram)
    total = copy.copy(ram)
    disk['keys'] = []
    total['keys'] = []
    def GetInHMS(seconds):
        hours = math.floor(seconds / 3600)
        seconds -= hours * 3600
        minutes = math.floor(seconds / 60)
        seconds -= minutes * 60
        seconds = math.floor(seconds)
        return (hours, minutes, seconds)
    if is_gae:
        gae_stats = cache.ram.client.get_stats()
        try:
            gae_stats['ratio'] = ((gae_stats['hits'] * 100) / (gae_stats['hits'] + gae_stats['misses']))
        except ZeroDivisionError:
            gae_stats['ratio'] = T('?')
        gae_stats['oldest'] = GetInHMS(time.time() - gae_stats['oldest_item_age'])
        total.update(gae_stats)
    else:
        ram_stats = cache.ram.stats[request.application]
        ram['hits'] = ram_stats['hit_total'] - ram_stats['misses']
        ram['misses'] = ram_stats['misses']
        try:
            ram['ratio'] = ram['hits'] * 100 / ram_stats['hit_total']
        except (KeyError, ZeroDivisionError):
            ram['ratio'] = 0
        for key, value in list(cache.ram.storage.items()):
            if asizeof:
                ram['bytes'] += asizeof(value[1])
                ram['objects'] += 1
            ram['entries'] += 1
            if value[0] < ram['oldest']:
                ram['oldest'] = value[0]
            ram['keys'].append((key, GetInHMS(time.time() - value[0])))
        for key in cache.disk.storage:
            value = cache.disk.storage[key]
            if key == 'web2py_cache_statistics' and isinstance(value[1], dict):
                disk['hits'] = value[1]['hit_total'] - value[1]['misses']
                disk['misses'] = value[1]['misses']
                try:
                    disk['ratio'] = disk['hits'] * 100 / value[1]['hit_total']
                except (KeyError, ZeroDivisionError):
                    disk['ratio'] = 0
            else:
                if asizeof:
                    disk['bytes'] += asizeof(value[1])
                    disk['objects'] += 1
                disk['entries'] += 1
                if value[0] < disk['oldest']:
                    disk['oldest'] = value[0]
                disk['keys'].append((key, GetInHMS(time.time() - value[0])))
        ram_keys = list(ram)
        for k in ['ratio', 'oldest']:
            if k in ram_keys:
                ram_keys.remove(k)
        for key in ram_keys:
            total[key] = ram[key] + disk[key]
        try:
            total['ratio'] = total['hits'] * 100 / (total['hits'] + total['misses'])
        except (KeyError, ZeroDivisionError):
            total['ratio'] = 0
        total['oldest'] = disk['oldest'] if disk['oldest'] < ram['oldest'] else ram['oldest']
        ram['oldest'] = GetInHMS(time.time() - ram['oldest'])
        disk['oldest'] = GetInHMS(time.time() - disk['oldest'])
        total['oldest'] = GetInHMS(time.time() - total['oldest'])
    def key_table(keys):
        return TABLE(
            TR(TD(B(T('Key'))), TD(B(T('Time in Cache (h:m:s)')))),
            *[TR(TD(k[0]), TD('%02d:%02d:%02d' % k[1])) for k in keys],
            _class='cache-keys',
            _style='border-collapse: separate; border-spacing: .5em;'
        )
    if not is_gae:
        ram['keys'] = key_table(ram['keys'])
        disk['keys'] = key_table(disk['keys'])
        total['keys'] = key_table(total['keys'])
    return dict(
        form=form,
        total=total,
        ram=ram,
        disk=disk,
        object_stats=asizeof is not False
    )

def table_template(table):
    """
    Generate a simple HTML table template for the given table schema.
    """
    from gluon.html import TR, TD, TABLE, TAG

    def FONT(*args, **kwargs):
        return TAG.font(*args, **kwargs)

    def types(field):
        f_type = field.type
        if not isinstance(f_type, str):
            return ' '
        elif f_type == 'string':
            return field.length
        elif f_type == 'id':
            return B('pk')
        elif f_type.startswith('reference') or f_type.startswith('list:reference'):
            return B('fk')
        else:
            return ' '
    rows = []
    cellpadding = 4
    color = '#000000'
    bgcolor = '#FFFFFF'
    face = 'Helvetica'
    face_bold = 'Helvetica Bold'
    border = 0
    rows.append(TR(TD(FONT(table, _face=face_bold, _color=bgcolor),
                      _colspan=3, _cellpadding=cellpadding,
                      _align='center', _bgcolor=color)))
    for row in db[table]:
        rows.append(
            TR(
                TD(FONT(row.name, _color=color, _face=face_bold),
                   _align='left', _cellpadding=cellpadding, _border=border),
                TD(FONT(row.type, _color=color, _face=face),
                   _align='left', _cellpadding=cellpadding, _border=border),
                TD(FONT(types(row), _color=color, _face=face),
                   _align='center', _cellpadding=cellpadding, _border=border)
            )
        )
    return f'< {TABLE(*rows, _bgcolor=bgcolor, _border=1, _cellborder=0, _cellspacing=0).xml()} >'

def manage():
    """
    Render a management interface (smartgrid) for the requested manager action.
    """
    tables = manager_action['tables']
    if isinstance(tables[0], str):
        dbobj = manager_action.get('db', auth.db)
        dbobj = globals()[dbobj] if isinstance(dbobj, str) else dbobj
        tables = [dbobj[table] for table in tables]
    if request.args(0) == 'auth':
        auth.table_user()._plural = T('Users')
        auth.table_group()._plural = T('Roles')
        auth.table_membership()._plural = T('Memberships')
        auth.table_permission()._plural = T('Permissions')
        if tables and tables[0] == auth.table_user():
            linked_tables = [auth.settings.table_membership_name]
    if request.extension != 'load':
        return dict(
            heading=manager_action.get('heading', T('Manage %(action)s') % dict(action=request.args(0).replace('_', ' ').title())),
            tablenames=[table._tablename for table in tables],
            labels=[table._plural.title() for table in tables]
        )
    table = tables[request.args(1, cast=int)]
    formname = f'{table._tablename}_grid'
    linked_tables = None
    orderby = None
    if request.args(0) == 'auth':
        auth.table_group()._id.readable = auth.table_membership()._id.readable = auth.table_permission()._id.readable = False
        auth.table_membership().user_id.label = T('User')
        auth.table_membership().group_id.label = T('Role')
        auth.table_permission().group_id.label = T('Role')
        auth.table_permission().name.label = T('Permission')
        if table == auth.table_user():
            linked_tables = [auth.settings.table_membership_name]
        elif table == auth.table_group():
            orderby = 'role' if not request.args(3) or '.group_id' not in request.args(3) else None
        elif table == auth.table_permission():
            orderby = 'group_id'
    kwargs = dict(user_signature=True, maxtextlength=1000,
                  orderby=orderby, linked_tables=linked_tables)
    smartgrid_args = manager_action.get('smartgrid_args', {})
    kwargs.update(smartgrid_args.get('DEFAULT', {}))
    kwargs.update(smartgrid_args.get(table._tablename, {}))
    grid = SQLFORM.smartgrid(table, args=request.args[:2], formname=formname, **kwargs)
    return grid

def hooks():
    """
    Aggregate hook functions (before/after insert/update/delete) for all tables.
    """
    import functools
    import inspect
    list_op = [f'_{h}_{m}' for h in ['before', 'after'] for m in ['insert', 'update', 'delete']]
    tables_list = []
    with_build_it = False
    for db_str in sorted(databases):
        dbobj = databases[db_str]
        for t in dbobj.tables:
            method_hooks = []
            for op in list_op:
                functions = []
                for f in getattr(dbobj[t], op):
                    if hasattr(f, '__call__'):
                        try:
                            if isinstance(f, functools.partial):
                                f = f.func
                            filename = inspect.getsourcefile(f)
                            details = {
                                'funcname': f.__name__,
                                'filename': filename[len(request.folder):] if request.folder in filename else None,
                                'lineno': inspect.getsourcelines(f)[1]
                            }
                            if details['filename']:
                                details['url'] = URL(a='admin', c='default', f='edit', 
                                                     args=[request['application'], details['filename']],
                                                     vars={'lineno': details['lineno']})
                            if details['filename'] or with_build_it:
                                functions.append(details)
                        except Exception:
                            pass
                if functions:
                    method_hooks.append({'name': op, 'functions': functions})
            if method_hooks:
                tables_list.append({
                    'name': f'{db_str}.{t}',
                    'slug': IS_SLUG()(f'{db_str}.{t}')[0],
                    'method_hooks': method_hooks
                })
    ul_main = UL(_class='nav nav-list')
    for t in tables_list:
        ul_main.append(A(t['name'], _onclick=f"collapse('a_{t['slug']}')"))
        ul_t = UL(_class='nav nav-list', _id=f"a_{t['slug']}", _style='display:none')
        for op in t['method_hooks']:
            ul_t.append(LI(op['name']))
            ul_t.append(UL([LI(A(f['funcname'], _class='editor_filelink', _href=f.get('url'), 
                                 **{'_data-lineno': f['lineno']-1})) for f in op['functions']]))
        ul_main.append(ul_t)
    return ul_main

def d3_graph_model():
    """
    Create a visualization of the database schema using D3.js.
    Returns a dictionary with nodes (table definitions) and links (foreign key relationships).
    """
    nodes = []
    links = []
    for database in databases:
        dbobj = eval_in_global_env(database)
        for tablename in dbobj.tables:
            fields = []
            for field in dbobj[tablename]:
                f_type = field.type
                if not isinstance(f_type, str):
                    disp = ' '
                elif f_type == 'string':
                    disp = field.length
                elif f_type == 'id':
                    disp = 'PK'
                elif f_type.startswith('reference') or f_type.startswith('list:reference'):
                    disp = 'FK'
                else:
                    disp = ' '
                fields.append(dict(name=field.name, type=field.type, disp=disp))
                if isinstance(f_type, str) and (f_type.startswith('reference') or f_type.startswith('list:reference')):
                    referenced_table = f_type.split()[1].split('.')[0]
                    links.append(dict(source=tablename, target=referenced_table))
            nodes.append(dict(name=tablename, type='table', fields=fields))
    response.files.append(URL('admin', 'static', 'js/d3.min.js'))
    response.files.append(URL('admin', 'static', 'js/d3_graph.js'))
    return dict(databases=databases, nodes=nodes, links=links)
